{"data":{"markdownRemark":{"html":"<p>안드로이드에서 Intent를 사용해 갤러리나 사진앱을 통해 사진의 Uri를 가져오는 코드는 이렇습니다. </p>\n<pre><code>Intent intent = new Intent(Intent.ACTION_PICK);  \nintent.setType(MediaStore.Images.Media.CONTENT_TYPE);  \nstartActivityForResult(intent, 1000); \n</code></pre>\n<p>,</p>\n<pre><code>@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n    Uri imageUri = data.getData();\n    Bitmap bitmap = BitmapFactory.decodeFile(getPath(imageUri));\n}\npublic String getPath(Uri uri) {\n    String[] projection = {MediaStore.Images.Media.DATA};\n    String result = null\n    CursorLoader cursorLoader = new CursorLoader(this, uri, projection, null, null, null);\n    Cursor cursor = cursorLoader.loadInBackground();\n    if (cursor != null) {\n        int columnIndex = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);\n        cursor.moveToFirst();\n        result = cursor.getString(columnIndex);\n    }\n        return result;\n}\n</code></pre>\n<p>파일로 읽어오기 때문에 퍼미션도 줘야 합니다.</p>\n<p>간단하게(?) 이정도면 내장된 이미지를 Bitmap으로 가져올 수 있습니다.</p>\n<p>그런데 이렇게 해서 못가져오는 이미지가 있는데.. 갤러리에서 Picasa의 싱크되어있는 이미지를 선택하게 되면 에러가 나게 됩니다. 이땐 다른 방법을 사용해야 합니다.</p>\n<p>에러의 이유는 갤러리에서 가져온 Uri의 위치 때문입니다.</p>\n<p>picasa에 sync된 이미지를 썸네일로 보여주는 건 캐싱되어 있을 것이지만 실제 파일은 서버에 있을테니 Uri 주소는 다른 사진의 Uri와 다른 주소를 가지고 있습니다.</p>\n<p><strong>일반적인 이미지 Uri</strong> “content://media/external/images/media/122733″<br>\n<strong>Sync된 이미지 Uri</strong> “content://com.google.android.gallery3d.provider/picasa/item/122733″  </p>\n<p>보통 이미지의 Uri는 메모리의 위치를 가지고 있지만 Sync 된 이미지의 Uri는 앱의 위치를 가지고 있습니다…</p>\n<p>그래서 해결방법은</p>\n<pre><code>@Override\n protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n     Uri uri = data.getData();\n     String[] projection = {MediaStore.Images.Media.DATA};\n     CursorLoader cursorLoader = new CursorLoader(this, uri, projection, null, null, null);\n     Cursor cursor = cursorLoader.loadInBackground();\n     if (cursor != null) {\n         cursor.moveToFirst();\n     }\n     Bitmap outBitmap = null;\n     File file = new File(Environment.getExternalStorageDirectory(), \"photo.jpg\");\n     InputStream input = null;\n     OutputStream output = null;\n     try {\n         input = getContentResolver().openInputStream(uri);\n         output = new FileOutputStream(file);\n         copyStream(input, output);\n         output.close();\n         outBitmap = BitmapFactory.decodeStream(new FileInputStream(file));\n         output.close();\n         input.close();\n     } catch (FileNotFoundException e) {\n         e.printStackTrace();\n     } catch (IOException e) {\n         e.printStackTrace();\n     }\n    cursor.close();\n}\n</code></pre>\n<p>이걸보고 앞에 Cursor를 왜 썼는지 궁금해 하실 수도 있을거 같습니다. 저 Cursor를 쓰지 않으면 FileNotFound 에러를 던집니다. Cursor로 가리키고 있어야 파일로 읽을 수 있는것입니다.</p>\n<p>그리고 임시의 파일에 스트림을 사용해서 이미지를 저장하고 그 파일을 읽어오는 방법입니다.</p>\n<p>코드가 조금 길어졌지만 파일로 캐싱 후 이미지를 로딩하는 방법이 필요하다면 이 방법 을 사용하시면 되겠습니다.</p>\n<p>파일캐싱이 필요없다면!!</p>\n<p>굉장히 짧은 코드로 끝납니다..</p>\n<pre><code>try {\n    InputStream is = getContentResolver().openInputStream(imageUri);\n    Bitmap bitmap = BitmapFactory.decodeStream(is);\n} catch (FileNotFoundException e) {\n    e.printStackTrace();\n}\n</code></pre>\n<p>앞서 설명했던 코드를 보시고 이 코드를 보시면 이해하기 수월하실 수도 있습니다;;</p>\n<p>BitmapFactory 클래스에서 바로 스트림으로 부터 디코딩을 해주는 메소드가 있어서 그걸 쓰면 코드가 짧아집니다;</p>\n<p>위의 긴 코드로 구현했던 부분은 input스트림과 output스트림을 모두 직접 구현한 것이고, BitmapFactory 클래스엔 위에 구현한 것이 이미 구현된 것이라 보시면 되겠네요 개발 방향에 따라 좋은방향으로 사용하면 되겠습니다.</p>\n<blockquote>예제로 보여드린 코드는 안드로이드에서 실제 구현하실 때 비동기로 구현하셔야 문제가 없습니다.</blockquote>","frontmatter":{"date":"2014.Apr.03","path":"/2014-04-03-android-get-picasa-images","title":"갤러리에서 Picasa나 Google+의 Sync된 이미지를 가져오는 방법"}}},"pageContext":{}}